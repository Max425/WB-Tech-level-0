package main

import "fmt"

//1. **Не буферизированные каналы:**
//- В не буферизированных каналах данные передаются синхронно между отправителем и получателем.
//- Когда данные отправляются в не буферизированный канал (через оператор `<-`), отправитель блокируется, пока получатель
//  не примет данные из канала (или пока получатель не закроет канал).
//- Когда данные принимаются из не буферизированного канала (также через оператор `<-`), получатель блокируется, пока
//  данные не будут доступны для получения.
//- Не буферизированные каналы обеспечивают точную синхронизацию между горутинами и гарантируют безопасную передачу
//  данных, но могут вызывать блокировку, если отправитель и получатель не синхронизированы.
//
//2. **Буферизированные каналы:**
//- В буферизированных каналах данные могут быть переданы асинхронно.
//- Буферизированный канал имеет фиксированную емкость, определяющую количество элементов, которые могут быть сохранены в
//  канале, прежде чем отправитель начнет блокироваться.
//- Когда данные отправляются в буферизированный канал, отправитель блокируется только если буфер канала полон.Если буфер
//  не полон, данные просто помещаются в буфер и отправитель продолжает выполнение.
//- Когда данные принимаются из буферизированного канала, получатель блокируется только если буфер канала пуст.Если буфер
//  не пуст, получатель получает данные из буфера и продолжает выполнение.
//- Буферизированные каналы обеспечивают асинхронную передачу данных между горутинами, что может улучшить
//  производительность, но могут быть менее надежными в смысле синхронизации.
//
//В общем, если важна точная синхронизация между горутинами или если необходимо избежать блокировок, лучше использовать не
//буферизированные каналы.Если же требуется асинхронная передача данных и увеличение пропускной способности, то
//буферизированные каналы могут быть предпочтительны.

func main() {
	ch := make(chan int)
	var n int
	fmt.Scanln(&n)
	bufferCh := make(chan int, n)
	bufferCh <- 10
	fmt.Println(ch, bufferCh)
}
